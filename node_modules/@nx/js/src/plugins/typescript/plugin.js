"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createNodesV2 = exports.PLUGIN_NAME = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const minimatch_1 = require("minimatch");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const ts_config_1 = require("../../utils/typescript/ts-config");
const util_1 = require("./util");
const pmc = (0, devkit_1.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return process.env.NX_CACHE_PROJECT_GRAPH !== 'false' && (0, node_fs_1.existsSync)(cachePath)
        ? (0, devkit_1.readJsonFile)(cachePath)
        : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
/**
 * @deprecated The 'createDependencies' function is now a no-op. This functionality is included in 'createNodesV2'.
 */
const createDependencies = () => {
    return [];
};
exports.createDependencies = createDependencies;
exports.PLUGIN_NAME = '@nx/js/typescript';
const tsConfigGlob = '**/tsconfig*.json';
exports.createNodesV2 = [
    tsConfigGlob,
    async (configFilePaths, options, context) => {
        const optionsHash = (0, file_hasher_1.hashObject)(options);
        const cachePath = (0, node_path_1.join)(cache_directory_1.workspaceDataDirectory, `tsc-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        const normalizedOptions = normalizePluginOptions(options);
        const lockFileName = (0, lock_file_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot));
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, options, context) => createNodesInternal(configFile, options, context, lockFileName, targetsCache), configFilePaths, normalizedOptions, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
exports.createNodes = [
    tsConfigGlob,
    async (configFilePath, options, context) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        const normalizedOptions = normalizePluginOptions(options);
        const lockFileName = (0, lock_file_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot));
        return createNodesInternal(configFilePath, normalizedOptions, context, lockFileName, {});
    },
];
async function createNodesInternal(configFilePath, options, context, lockFileName, targetsCache) {
    const projectRoot = (0, node_path_1.dirname)(configFilePath);
    const fullConfigPath = (0, devkit_1.joinPathFragments)(context.workspaceRoot, configFilePath);
    // Do not create a project for the workspace root tsconfig files.
    if (projectRoot === '.') {
        return {};
    }
    // Do not create a project if package.json and project.json isn't there.
    const siblingFiles = (0, node_fs_1.readdirSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot));
    if (!siblingFiles.includes('package.json') &&
        !siblingFiles.includes('project.json')) {
        return {};
    }
    // Do not create a project if it's not a tsconfig.json and there is no tsconfig.json in the same directory
    if ((0, node_path_1.basename)(configFilePath) !== 'tsconfig.json' &&
        !siblingFiles.includes('tsconfig.json')) {
        return {};
    }
    // Do not create project for Next.js projects since they are not compatible with
    // project references and typecheck will fail.
    if (siblingFiles.includes('next.config.js') ||
        siblingFiles.includes('next.config.cjs') ||
        siblingFiles.includes('next.config.mjs') ||
        siblingFiles.includes('next.config.ts')) {
        return {};
    }
    /**
     * The cache key is composed by:
     * - hashes of the content of the relevant files that can affect what's inferred by the plugin:
     *   - current config file
     *   - config files extended by the current config file (recursively up to the root config file)
     *   - referenced config files that are internal to the owning Nx project of the current config file, or is a shallow external reference of the owning Nx project
     *   - lock file
     * - hash of the plugin options
     * - current config file path
     */
    const tsConfig = readCachedTsConfig(fullConfigPath);
    const extendedConfigFiles = getExtendedConfigFiles(fullConfigPath, tsConfig);
    const internalReferencedFiles = resolveInternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
    const externalProjectReferences = resolveShallowExternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
    const packageJsonPath = (0, devkit_1.joinPathFragments)(projectRoot, 'package.json');
    const packageJson = (0, node_fs_1.existsSync)(packageJsonPath)
        ? (0, devkit_1.readJsonFile)(packageJsonPath)
        : null;
    const nodeHash = (0, file_hasher_1.hashArray)([
        ...[
            fullConfigPath,
            ...extendedConfigFiles.files,
            ...Object.keys(internalReferencedFiles),
            ...Object.keys(externalProjectReferences),
            (0, node_path_1.join)(context.workspaceRoot, lockFileName),
        ].map(file_hasher_1.hashFile),
        (0, file_hasher_1.hashObject)(options),
        ...(packageJson ? [(0, file_hasher_1.hashObject)(packageJson)] : []),
    ]);
    const cacheKey = `${nodeHash}_${configFilePath}`;
    targetsCache[cacheKey] ??= buildTscTargets(fullConfigPath, projectRoot, options, context);
    const { targets } = targetsCache[cacheKey];
    return {
        projects: {
            [projectRoot]: {
                projectType: 'library',
                targets,
            },
        },
    };
}
function buildTscTargets(configFilePath, projectRoot, options, context) {
    const targets = {};
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const tsConfig = readCachedTsConfig(configFilePath);
    let internalProjectReferences;
    // Typecheck target
    if ((0, node_path_1.basename)(configFilePath) === 'tsconfig.json' && options.typecheck) {
        internalProjectReferences = resolveInternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
        const externalProjectReferences = resolveShallowExternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
        const targetName = options.typecheck.targetName;
        if (!targets[targetName]) {
            let command = `tsc --build --emitDeclarationOnly${options.verboseOutput ? ' --verbose' : ''}`;
            if (tsConfig.options.noEmit ||
                Object.values(internalProjectReferences).some((ref) => ref.options.noEmit) ||
                Object.values(externalProjectReferences).some((ref) => ref.options.noEmit)) {
                // `tsc --build` does not work with `noEmit: true`
                command = `echo "The 'typecheck' target is disabled because one or more project references set 'noEmit: true' in their tsconfig. Remove this property to resolve this issue."`;
            }
            targets[targetName] = {
                dependsOn: [`^${targetName}`],
                command,
                options: { cwd: projectRoot },
                cache: true,
                inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
                outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
                syncGenerators: ['@nx/js:typescript-sync'],
                metadata: {
                    technologies: ['typescript'],
                    description: 'Runs type-checking for the project.',
                    help: {
                        command: `${pmc.exec} tsc --build --help`,
                        example: {
                            args: ['--force'],
                        },
                    },
                },
            };
        }
    }
    // Build target
    if (options.build &&
        (0, node_path_1.basename)(configFilePath) === options.build.configName &&
        isValidPackageJsonBuildConfig(tsConfig, context.workspaceRoot, projectRoot)) {
        internalProjectReferences ??= resolveInternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
        const targetName = options.build.targetName;
        targets[targetName] = {
            dependsOn: [`^${targetName}`],
            command: `tsc --build ${options.build.configName}${options.verboseOutput ? ' --verbose' : ''}`,
            options: { cwd: projectRoot },
            cache: true,
            inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            syncGenerators: ['@nx/js:typescript-sync'],
            metadata: {
                technologies: ['typescript'],
                description: 'Builds the project with `tsc`.',
                help: {
                    command: `${pmc.exec} tsc --build --help`,
                    example: {
                        args: ['--force'],
                    },
                },
            },
        };
        (0, util_1.addBuildAndWatchDepsTargets)(context.workspaceRoot, projectRoot, targets, {
            buildDepsTargetName: options.build.buildDepsName,
            watchDepsTargetName: options.build.watchDepsName,
        }, pmc);
    }
    return { targets };
}
function getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const configFiles = new Set();
    const externalDependencies = ['typescript'];
    const extendedConfigFiles = getExtendedConfigFiles(configFilePath, tsConfig);
    extendedConfigFiles.files.forEach((configPath) => {
        configFiles.add(configPath);
    });
    externalDependencies.push(...extendedConfigFiles.packages);
    const includePaths = new Set();
    const excludePaths = new Set();
    const projectTsConfigFiles = [
        [configFilePath, tsConfig],
        ...Object.entries(internalProjectReferences),
    ];
    const absoluteProjectRoot = (0, node_path_1.join)(workspaceRoot, projectRoot);
    projectTsConfigFiles.forEach(([configPath, config]) => {
        configFiles.add(configPath);
        const offset = (0, node_path_1.relative)(absoluteProjectRoot, (0, node_path_1.dirname)(configPath));
        (config.raw?.include ?? []).forEach((p) => includePaths.add((0, node_path_1.join)(offset, p)));
        if (config.raw?.exclude) {
            /**
             * We need to filter out the exclude paths that are already included in
             * other tsconfig files. If they are not included in other tsconfig files,
             * they still correctly apply to the current file and we should keep them.
             */
            const otherFilesInclude = [];
            projectTsConfigFiles.forEach(([path, c]) => {
                if (path !== configPath) {
                    otherFilesInclude.push(...(c.raw?.include ?? []));
                }
            });
            const normalize = (p) => (p.startsWith('./') ? p.slice(2) : p);
            config.raw.exclude.forEach((excludePath) => {
                if (!otherFilesInclude.some((includePath) => (0, minimatch_1.minimatch)(normalize(includePath), normalize(excludePath)) ||
                    (0, minimatch_1.minimatch)(normalize(excludePath), normalize(includePath)))) {
                    excludePaths.add(excludePath);
                }
            });
        }
    });
    const inputs = [];
    if (includePaths.size) {
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(workspaceRoot, projectRoot, 'package.json'))) {
            inputs.push('{projectRoot}/package.json');
        }
        inputs.push(...Array.from(configFiles).map((p) => pathToInputOrOutput(p, workspaceRoot, projectRoot)), ...Array.from(includePaths).map((p) => pathToInputOrOutput((0, devkit_1.joinPathFragments)(projectRoot, p), workspaceRoot, projectRoot)));
    }
    else {
        // If we couldn't identify any include paths, we default to the default
        // named inputs.
        inputs.push('production' in namedInputs ? 'production' : 'default');
    }
    if (excludePaths.size) {
        inputs.push(...Array.from(excludePaths).map((p) => `!${pathToInputOrOutput((0, devkit_1.joinPathFragments)(projectRoot, p), workspaceRoot, projectRoot)}`));
    }
    if (hasExternalProjectReferences(configFilePath, tsConfig, workspaceRoot, projectRoot)) {
        // Importing modules from a referenced project will load its output declaration files (d.ts)
        // https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference
        inputs.push({ dependentTasksOutputFiles: '**/*.d.ts' });
    }
    else {
        inputs.push('production' in namedInputs ? '^production' : '^default');
    }
    inputs.push({ externalDependencies });
    return inputs;
}
function getOutputs(configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const outputs = new Set();
    // We could have more surgical outputs based on the tsconfig options, but the
    // user could override them through the command line and that wouldn't be
    // reflected in the outputs. So, we just include everything that could be
    // produced by the tsc command.
    [tsConfig, ...Object.values(internalProjectReferences)].forEach((config) => {
        if (config.options.outFile) {
            const outFileName = (0, node_path_1.basename)(config.options.outFile, '.js');
            const outFileDir = (0, node_path_1.dirname)(config.options.outFile);
            outputs.add(pathToInputOrOutput(config.options.outFile, workspaceRoot, projectRoot));
            // outFile is not be used with .cjs, .mjs, .jsx, so the list is simpler
            const outDir = (0, node_path_1.relative)(workspaceRoot, outFileDir);
            outputs.add(pathToInputOrOutput((0, devkit_1.joinPathFragments)(outDir, `${outFileName}.js.map`), workspaceRoot, projectRoot));
            outputs.add(pathToInputOrOutput((0, devkit_1.joinPathFragments)(outDir, `${outFileName}.d.ts`), workspaceRoot, projectRoot));
            outputs.add(pathToInputOrOutput((0, devkit_1.joinPathFragments)(outDir, `${outFileName}.d.ts.map`), workspaceRoot, projectRoot));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : pathToInputOrOutput((0, devkit_1.joinPathFragments)(outDir, `${outFileName}.tsbuildinfo`), workspaceRoot, projectRoot));
        }
        else if (config.options.outDir) {
            outputs.add(pathToInputOrOutput(config.options.outDir, workspaceRoot, projectRoot));
            if (config.options.tsBuildInfoFile) {
                if (!(0, node_path_1.normalize)(config.options.tsBuildInfoFile).startsWith(`${(0, node_path_1.normalize)(config.options.outDir)}${node_path_1.sep}`)) {
                    // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
                    outputs.add(pathToInputOrOutput(config.options.tsBuildInfoFile, workspaceRoot, projectRoot));
                }
            }
            else if (config.options.rootDir && config.options.rootDir !== '.') {
                // If rootDir is set, then the tsbuildinfo file will be outside the outDir so we need to add it.
                const relativeRootDir = (0, node_path_1.relative)(config.options.rootDir, (0, node_path_1.join)(workspaceRoot, projectRoot));
                outputs.add(pathToInputOrOutput((0, devkit_1.joinPathFragments)(config.options.outDir, relativeRootDir, `*.tsbuildinfo`), workspaceRoot, projectRoot));
            }
        }
        else if (config.fileNames.length) {
            // tsc produce files in place when no outDir or outFile is set
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.cjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.mjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js.map')); // should also include .cjs and .mjs data
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts.map'));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            const name = (0, node_path_1.basename)(configFilePath, '.json');
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : (0, devkit_1.joinPathFragments)('{projectRoot}', `${name}.tsbuildinfo`));
        }
    });
    return Array.from(outputs);
}
/**
 * Validates the build configuration of a `package.json` file by ensuring that paths in the `exports`, `module`,
 * and `main` fields reference valid output paths within the `outDir` defined in the TypeScript configuration.
 * Priority is given to the `exports` field, specifically the `.` export if defined. If `exports` is not defined,
 * the function falls back to validating `main` and `module` fields. If `outFile` is specified, it validates that the file
 * is located within the output directory.
 * If no `package.json` file exists, it assumes the configuration is valid.
 *
 * @param tsConfig The TypeScript configuration object.
 * @param workspaceRoot The workspace root path.
 * @param projectRoot The project root path.
 * @returns `true` if the package has a valid build configuration; otherwise, `false`.
 */
function isValidPackageJsonBuildConfig(tsConfig, workspaceRoot, projectRoot) {
    const packageJsonPath = (0, node_path_1.join)(workspaceRoot, projectRoot, 'package.json');
    if (!(0, node_fs_1.existsSync)(packageJsonPath)) {
        // If the package.json file does not exist.
        // Assume it's valid because it would be using `project.json` instead.
        return true;
    }
    const packageJson = (0, devkit_1.readJsonFile)(packageJsonPath);
    const outDir = tsConfig.options.outFile
        ? (0, node_path_1.dirname)(tsConfig.options.outFile)
        : tsConfig.options.outDir;
    const resolvedOutDir = outDir
        ? (0, node_path_1.resolve)(workspaceRoot, projectRoot, outDir)
        : undefined;
    const isPathSourceFile = (path) => {
        if (resolvedOutDir) {
            const pathToCheck = (0, node_path_1.resolve)(workspaceRoot, projectRoot, path);
            return !pathToCheck.startsWith(resolvedOutDir);
        }
        const ext = (0, node_path_1.extname)(path);
        // Check that the file extension is a TS file extension. As the source files are in the same directory as the output files.
        return ['.ts', '.tsx', '.cts', '.mts'].includes(ext);
    };
    // Checks if the value is a path within the `src` directory.
    const containsInvalidPath = (value) => {
        if (typeof value === 'string') {
            return isPathSourceFile(value);
        }
        else if (typeof value === 'object') {
            return Object.entries(value).some(([currentKey, subValue]) => {
                // Skip types field
                if (currentKey === 'types') {
                    return false;
                }
                if (typeof subValue === 'string') {
                    return isPathSourceFile(subValue);
                }
                return false;
            });
        }
        return false;
    };
    const exports = packageJson?.exports;
    // Check the `.` export if `exports` is defined.
    if (exports) {
        if (typeof exports === 'string') {
            return !isPathSourceFile(exports);
        }
        if (typeof exports === 'object' && '.' in exports) {
            return !containsInvalidPath(exports['.']);
        }
        // Check other exports if `.` is not defined or valid.
        for (const key in exports) {
            if (key !== '.' && containsInvalidPath(exports[key])) {
                return false;
            }
        }
        return true;
    }
    // If `exports` is not defined, fallback to `main` and `module` fields.
    const buildPaths = ['main', 'module'];
    for (const field of buildPaths) {
        if (packageJson[field] && isPathSourceFile(packageJson[field])) {
            return false;
        }
    }
    return true;
}
function pathToInputOrOutput(path, workspaceRoot, projectRoot) {
    const fullProjectRoot = (0, node_path_1.resolve)(workspaceRoot, projectRoot);
    const fullPath = (0, node_path_1.resolve)(workspaceRoot, path);
    const pathRelativeToProjectRoot = (0, devkit_1.normalizePath)((0, node_path_1.relative)(fullProjectRoot, fullPath));
    if (pathRelativeToProjectRoot.startsWith('..')) {
        return (0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, fullPath));
    }
    return (0, devkit_1.joinPathFragments)('{projectRoot}', pathRelativeToProjectRoot);
}
function getExtendedConfigFiles(tsConfigPath, tsConfig) {
    const extendedConfigFiles = new Set();
    const extendedExternalPackages = new Set();
    let currentConfigPath = tsConfigPath;
    let currentConfig = tsConfig;
    while (currentConfig.raw?.extends) {
        const extendedConfigPath = resolveExtendedTsConfigPath(currentConfig.raw.extends, (0, node_path_1.dirname)(currentConfigPath));
        if (!extendedConfigPath) {
            break;
        }
        if (extendedConfigPath.externalPackage) {
            extendedExternalPackages.add(extendedConfigPath.externalPackage);
            break;
        }
        extendedConfigFiles.add(extendedConfigPath.filePath);
        currentConfig = readCachedTsConfig(extendedConfigPath.filePath);
        currentConfigPath = extendedConfigPath.filePath;
    }
    return {
        files: Array.from(extendedConfigFiles),
        packages: Array.from(extendedExternalPackages),
    };
}
function resolveInternalProjectReferences(tsConfig, workspaceRoot, projectRoot, projectReferences = {}) {
    walkProjectReferences(tsConfig, workspaceRoot, projectRoot, (configPath, config) => {
        if (isExternalProjectReference(configPath, workspaceRoot, projectRoot)) {
            return false;
        }
        else {
            projectReferences[configPath] = config;
        }
    });
    return projectReferences;
}
function resolveShallowExternalProjectReferences(tsConfig, workspaceRoot, projectRoot, projectReferences = {}) {
    walkProjectReferences(tsConfig, workspaceRoot, projectRoot, (configPath, config) => {
        if (isExternalProjectReference(configPath, workspaceRoot, projectRoot)) {
            projectReferences[configPath] = config;
        }
        return false;
    });
    return projectReferences;
}
function walkProjectReferences(tsConfig, workspaceRoot, projectRoot, visitor, // false stops recursion
projectReferences = {}) {
    if (!tsConfig.projectReferences?.length) {
        return projectReferences;
    }
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (projectReferences[refConfigPath]) {
            // Already resolved
            continue;
        }
        if (!(0, node_fs_1.existsSync)(refConfigPath)) {
            // the referenced tsconfig doesn't exist, ignore it
            continue;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        const result = visitor(refConfigPath, refTsConfig);
        if (result !== false) {
            walkProjectReferences(refTsConfig, workspaceRoot, projectRoot, visitor);
        }
    }
    return projectReferences;
}
function hasExternalProjectReferences(tsConfigPath, tsConfig, workspaceRoot, projectRoot, seen = new Set()) {
    if (!tsConfig.projectReferences?.length) {
        return false;
    }
    seen.add(tsConfigPath);
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (seen.has(refConfigPath)) {
            // Already seen
            continue;
        }
        if (!(0, node_fs_1.existsSync)(refConfigPath)) {
            // the referenced tsconfig doesn't exist, ignore it
            continue;
        }
        if (isExternalProjectReference(refConfigPath, workspaceRoot, projectRoot)) {
            return true;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        const result = hasExternalProjectReferences(refConfigPath, refTsConfig, workspaceRoot, projectRoot, seen);
        if (result) {
            return true;
        }
    }
    return false;
}
function isExternalProjectReference(refTsConfigPath, workspaceRoot, projectRoot) {
    const absoluteProjectRoot = (0, node_path_1.join)(workspaceRoot, projectRoot);
    let currentPath = getTsConfigDirName(refTsConfigPath);
    if ((0, node_path_1.relative)(absoluteProjectRoot, currentPath).startsWith('..')) {
        // it's outside of the project root, so it's an external project reference
        return true;
    }
    while (currentPath !== absoluteProjectRoot) {
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(currentPath, 'package.json')) ||
            (0, node_fs_1.existsSync)((0, node_path_1.join)(currentPath, 'project.json'))) {
            // it's inside a nested project root, so it's and external project reference
            return true;
        }
        currentPath = (0, node_path_1.dirname)(currentPath);
    }
    // it's inside the project root, so it's an internal project reference
    return false;
}
function getTsConfigDirName(tsConfigPath) {
    return (0, node_fs_1.statSync)(tsConfigPath).isFile()
        ? (0, node_path_1.dirname)(tsConfigPath)
        : (0, node_path_1.normalize)(tsConfigPath);
}
const tsConfigCache = new Map();
function readCachedTsConfig(tsConfigPath) {
    const cacheKey = getTsConfigCacheKey(tsConfigPath);
    if (tsConfigCache.has(cacheKey)) {
        return tsConfigCache.get(cacheKey);
    }
    const tsConfig = (0, ts_config_1.readTsConfig)(tsConfigPath);
    tsConfigCache.set(cacheKey, tsConfig);
    return tsConfig;
}
function getTsConfigCacheKey(tsConfigPath) {
    const timestamp = (0, node_fs_1.statSync)(tsConfigPath).mtimeMs;
    return `${tsConfigPath}-${timestamp}`;
}
function normalizePluginOptions(pluginOptions = {}) {
    const defaultTypecheckTargetName = 'typecheck';
    let typecheck = {
        targetName: defaultTypecheckTargetName,
    };
    if (pluginOptions.typecheck === false) {
        typecheck = false;
    }
    else if (pluginOptions.typecheck &&
        typeof pluginOptions.typecheck !== 'boolean') {
        typecheck = {
            targetName: pluginOptions.typecheck.targetName ?? defaultTypecheckTargetName,
        };
    }
    const defaultBuildTargetName = 'build';
    const defaultBuildConfigName = 'tsconfig.lib.json';
    let build = {
        targetName: defaultBuildTargetName,
        configName: defaultBuildConfigName,
        buildDepsName: 'build-deps',
        watchDepsName: 'watch-deps',
    };
    // Build target is not enabled by default
    if (!pluginOptions.build) {
        build = false;
    }
    else if (pluginOptions.build && typeof pluginOptions.build !== 'boolean') {
        build = {
            targetName: pluginOptions.build.targetName ?? defaultBuildTargetName,
            configName: pluginOptions.build.configName ?? defaultBuildConfigName,
            buildDepsName: pluginOptions.build.buildDepsName ?? 'build-deps',
            watchDepsName: pluginOptions.build.watchDepsName ?? 'watch-deps',
        };
    }
    return {
        typecheck,
        build,
        verboseOutput: pluginOptions.verboseOutput ?? false,
    };
}
function resolveExtendedTsConfigPath(tsConfigPath, directory) {
    try {
        const resolvedPath = require.resolve(tsConfigPath, {
            paths: directory ? [directory] : undefined,
        });
        if (tsConfigPath.startsWith('.')) {
            return { filePath: resolvedPath };
        }
        // parse the package from the tsconfig path
        const packageName = tsConfigPath.startsWith('@')
            ? tsConfigPath.split('/').slice(0, 2).join('/')
            : tsConfigPath.split('/')[0];
        return { filePath: resolvedPath, externalPackage: packageName };
    }
    catch {
        return null;
    }
}
